/**
 * AgentOS Browser Recorder
 * 
 * Injected into browser pages to capture user interactions.
 * Outputs events in Chrome DevTools Recorder JSON format.
 * 
 * Selector Priority (Playwright best practices):
 * 1. Role + accessible name (ARIA)
 * 2. data-testid / data-test / data-qa
 * 3. Text content (for buttons, links)
 * 4. Label / placeholder (for inputs)
 * 5. Unique ID (if not auto-generated)
 * 6. CSS selector (fallback)
 */
(function() {
  // Prevent double-injection
  if (window.__agentosRecorderActive) return;
  window.__agentosRecorderActive = true;

  // Debounce helper for input events
  const debounceTimers = new Map();
  function debounce(key, fn, delay = 300) {
    clearTimeout(debounceTimers.get(key));
    debounceTimers.set(key, setTimeout(fn, delay));
  }

  /**
   * Check if an ID looks auto-generated (should be avoided).
   */
  function isAutoGeneratedId(id) {
    if (!id) return true;
    // Patterns that suggest auto-generated IDs
    return (
      id.length > 50 ||
      /^[a-f0-9-]{20,}$/i.test(id) ||  // UUID-like
      /^:r[a-z0-9]+:$/i.test(id) ||     // React auto IDs like :r1:, :ra:
      /^(ember|react|ng-|vue-|_r_)/i.test(id) ||  // Framework prefixes
      /^\d+$/.test(id) ||                // Pure numbers
      /[^\w-]/.test(id)                  // Contains special chars
    );
  }

  /**
   * Get the accessible name for an element (what screen readers announce).
   */
  function getAccessibleName(el) {
    // aria-label takes precedence
    const ariaLabel = el.getAttribute('aria-label');
    if (ariaLabel) return ariaLabel.trim();
    
    // aria-labelledby references another element
    const labelledBy = el.getAttribute('aria-labelledby');
    if (labelledBy) {
      const labelEl = document.getElementById(labelledBy);
      if (labelEl) return labelEl.textContent?.trim();
    }
    
    // For inputs, check associated label
    if (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA' || el.tagName === 'SELECT') {
      const label = el.labels?.[0];
      if (label) return label.textContent?.trim();
    }
    
    // Button/link text content
    if (el.tagName === 'BUTTON' || el.tagName === 'A' || el.getAttribute('role') === 'button') {
      const text = el.textContent?.trim();
      if (text && text.length < 50 && !text.includes('\n')) return text;
    }
    
    return null;
  }

  /**
   * Get the ARIA role for an element.
   */
  function getRole(el) {
    // Explicit role
    const explicitRole = el.getAttribute('role');
    if (explicitRole) return explicitRole;
    
    // Implicit roles based on tag
    const tagRoles = {
      'BUTTON': 'button',
      'A': 'link',
      'INPUT': el.type === 'checkbox' ? 'checkbox' : 
               el.type === 'radio' ? 'radio' : 
               el.type === 'submit' ? 'button' : null,
      'SELECT': 'combobox',
      'TEXTAREA': 'textbox',
      'IMG': 'img',
      'NAV': 'navigation',
      'MAIN': 'main',
      'HEADER': 'banner',
      'FOOTER': 'contentinfo',
    };
    
    return tagRoles[el.tagName] || null;
  }

  /**
   * Generate selectors for an element in Chrome DevTools Recorder format.
   * Returns array of selector arrays, prioritized by reliability.
   * 
   * Priority:
   * 1. aria/ selector (role + name)
   * 2. data-testid
   * 3. text= selector
   * 4. label/placeholder for inputs
   * 5. Unique ID
   * 6. CSS fallback
   */
  function getSelectors(el) {
    if (!el || el === document.body || el === document.documentElement) {
      return null;
    }

    const selectors = [];

    // 1. Role selector (Playwright's preferred format) - MOST RELIABLE
    const role = getRole(el);
    const accessibleName = getAccessibleName(el);
    if (role && accessibleName && accessibleName.length < 50) {
      // Use Playwright's role= format which is more reliable than aria/
      selectors.push([`role=${role}[name="${accessibleName}"]`]);
    }

    // 2. data-testid / data-test / data-qa - VERY RELIABLE
    const testId = el.getAttribute('data-testid') || 
                   el.getAttribute('data-test-id') || 
                   el.getAttribute('data-test') ||
                   el.getAttribute('data-qa');
    if (testId) {
      selectors.push([`[data-testid="${testId}"]`]);
    }

    // 3. Text selector for interactive elements - RELIABLE
    if (['BUTTON', 'A'].includes(el.tagName) || el.getAttribute('role') === 'button') {
      const text = el.textContent?.trim();
      if (text && text.length > 0 && text.length < 40 && !text.includes('\n')) {
        selectors.push([`text=${text}`]);
      }
    }

    // 4. Label/placeholder for inputs - RELIABLE
    if (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA') {
      const placeholder = el.getAttribute('placeholder');
      if (placeholder) {
        selectors.push([`${el.tagName.toLowerCase()}[placeholder="${placeholder}"]`]);
      }
      
      const name = el.getAttribute('name');
      if (name && name.length < 50) {
        selectors.push([`${el.tagName.toLowerCase()}[name="${name}"]`]);
      }
    }

    // 5. Unique ID (if not auto-generated) - SOMEWHAT RELIABLE
    if (el.id && !isAutoGeneratedId(el.id)) {
      selectors.push([`#${el.id}`]);
    }

    // 6. CSS path with context - MORE RELIABLE than generic tag
    const cssPath = buildCssPath(el);
    if (cssPath) {
      selectors.push([cssPath]);
    }

    // 7. XPath (smart version with attributes) - VERY RELIABLE
    const smartXPath = buildSmartXPath(el);
    if (smartXPath) {
      selectors.push([`xpath=${smartXPath}`]);
    }

    // 8. Full XPath path - LAST RESORT but ALWAYS UNIQUE
    const fullXPath = buildXPath(el);
    if (fullXPath && fullXPath !== smartXPath) {
      selectors.push([`xpath=${fullXPath}`]);
    }

    return selectors.length > 0 ? selectors : null;
  }

  /**
   * Build an XPath selector for an element.
   * Generates a full path from root that uniquely identifies the element.
   */
  function buildXPath(el) {
    if (!el || el === document) return '';
    
    const parts = [];
    let current = el;
    
    while (current && current !== document && current !== document.documentElement) {
      let selector = current.tagName.toLowerCase();
      
      // Add index if there are siblings with same tag
      const parent = current.parentElement;
      if (parent) {
        const siblings = Array.from(parent.children).filter(c => c.tagName === current.tagName);
        if (siblings.length > 1) {
          const index = siblings.indexOf(current) + 1;
          selector += `[${index}]`;
        }
      }
      
      parts.unshift(selector);
      current = parent;
    }
    
    return '//' + parts.join('/');
  }

  /**
   * Build a shorter XPath using attributes when available.
   */
  function buildSmartXPath(el) {
    const tag = el.tagName.toLowerCase();
    
    // Try ID first (if not auto-generated)
    if (el.id && !isAutoGeneratedId(el.id)) {
      return `//${tag}[@id="${el.id}"]`;
    }
    
    // Try data-testid
    const testId = el.getAttribute('data-testid');
    if (testId) {
      return `//${tag}[@data-testid="${testId}"]`;
    }
    
    // Try aria-label
    const ariaLabel = el.getAttribute('aria-label');
    if (ariaLabel) {
      return `//${tag}[@aria-label="${ariaLabel}"]`;
    }
    
    // Try text content for buttons/links
    if (['BUTTON', 'A'].includes(el.tagName)) {
      const text = el.textContent?.trim();
      if (text && text.length < 30 && !text.includes('\n') && !text.includes('"')) {
        return `//${tag}[text()="${text}"]`;
      }
    }
    
    // Fall back to full path
    return buildXPath(el);
  }

  /**
   * Build a CSS selector that's as specific as possible.
   * Avoids Tailwind utility classes.
   */
  function buildCssSelector(el) {
    const tag = el.tagName.toLowerCase();
    
    // Skip generic Tailwind/utility classes
    const utilityPattern = /^(flex|grid|block|inline|hidden|relative|absolute|fixed|sticky|w-|h-|min-|max-|p-|px-|py-|pt-|pb-|pl-|pr-|m-|mx-|my-|mt-|mb-|ml-|mr-|text-|font-|bg-|border|rounded|shadow|gap-|space-|items-|justify-|self-|col-|row-|overflow|z-|opacity-|transition|duration|ease-|cursor-|pointer-|select-|outline|ring|sr-only|not-sr-only|container|animate-)/;
    
    // Find meaningful classes
    const meaningfulClasses = Array.from(el.classList || [])
      .filter(c => c && !utilityPattern.test(c) && c.length < 40 && !c.startsWith('_'))
      .slice(0, 2);
    
    if (meaningfulClasses.length > 0) {
      const selector = `${tag}.${meaningfulClasses.join('.')}`;
      // Check if this selector is unique on the page
      if (document.querySelectorAll(selector).length === 1) {
        return selector;
      }
    }

    // Try with a meaningful data attribute
    const dataAttrs = Array.from(el.attributes)
      .filter(a => 
        a.name.startsWith('data-') && 
        !a.name.includes('sentry') && 
        !a.name.startsWith('data-radix') &&
        a.value.length < 50 &&
        a.value.length > 0
      )
      .slice(0, 1);
    
    if (dataAttrs.length > 0) {
      return `${tag}[${dataAttrs[0].name}="${dataAttrs[0].value}"]`;
    }

    // For inputs, use type
    if (el.tagName === 'INPUT') {
      const type = el.getAttribute('type') || 'text';
      return `input[type="${type}"]`;
    }

    // Build a more specific CSS path with parent context
    const path = buildCssPath(el);
    if (path) return path;

    return tag;
  }

  /**
   * Build a CSS selector path with parent context.
   */
  function buildCssPath(el, maxDepth = 3) {
    const utilityPattern = /^(flex|grid|block|inline|hidden|relative|absolute|fixed|sticky|w-|h-|min-|max-|p-|px-|py-|pt-|pb-|pl-|pr-|m-|mx-|my-|mt-|mb-|ml-|mr-|text-|font-|bg-|border|rounded|shadow|gap-|space-|items-|justify-|self-|col-|row-|overflow|z-|opacity-|transition|duration|ease-|cursor-|pointer-|select-|outline|ring|sr-only|not-sr-only|container|animate-)/;
    
    const parts = [];
    let current = el;
    let depth = 0;
    
    while (current && current !== document.body && depth < maxDepth) {
      const tag = current.tagName.toLowerCase();
      let part = tag;
      
      // Try to add distinguishing info
      if (current.id && !isAutoGeneratedId(current.id)) {
        part = `#${current.id}`;
        parts.unshift(part);
        break; // ID is unique, stop here
      }
      
      // Add meaningful class
      const meaningfulClass = Array.from(current.classList || [])
        .find(c => c && !utilityPattern.test(c) && c.length < 40);
      if (meaningfulClass) {
        part = `${tag}.${meaningfulClass}`;
      }
      
      // Add nth-child if needed
      const parent = current.parentElement;
      if (parent) {
        const siblings = Array.from(parent.children).filter(c => c.tagName === current.tagName);
        if (siblings.length > 1) {
          const index = siblings.indexOf(current) + 1;
          part += `:nth-of-type(${index})`;
        }
      }
      
      parts.unshift(part);
      current = parent;
      depth++;
    }
    
    return parts.join(' > ');
  }

  /**
   * Record a step (sends to daemon via exposed function).
   */
  function record(step) {
    // Add metadata for debugging
    step._url = window.location.href;
    step._timestamp = Date.now();

    if (typeof window.__agentosRecord === 'function') {
      window.__agentosRecord(step);
    } else {
      console.log('[AgentOS Recorder] Event:', step);
    }
  }

  // --- Track URL for navigation detection ---
  let lastUrl = window.location.href;
  let lastTitle = document.title;

  function checkNavigation() {
    const currentUrl = window.location.href;
    const currentTitle = document.title;
    
    if (currentUrl !== lastUrl) {
      record({ 
        type: 'navigate', 
        url: currentUrl,
        title: currentTitle || undefined
      });
      lastUrl = currentUrl;
      lastTitle = currentTitle;
    }
  }

  // --- Event Listeners ---

  // Click events - capture ALL clicks, even on elements without good selectors
  document.addEventListener('click', (e) => {
    // Log every click for debugging
    console.log('[AgentOS Recorder] Click detected:', e.target.tagName, e.target.textContent?.slice(0, 30));
    
    // Check for navigation that might have happened
    setTimeout(checkNavigation, 100);
    
    const selectors = getSelectors(e.target);
    
    // Record the click even if selectors aren't great
    record({
      type: 'click',
      selectors: selectors || [[e.target.tagName.toLowerCase()], [buildXPath(e.target)]],
      offsetX: Math.round(e.offsetX),
      offsetY: Math.round(e.offsetY),
      button: e.button === 2 ? 'secondary' : 'primary',
      // Add debug info
      _debug: {
        tagName: e.target.tagName,
        text: e.target.textContent?.slice(0, 50),
        className: e.target.className?.slice?.(0, 50)
      }
    });
  }, true);

  // Double-click events
  document.addEventListener('dblclick', (e) => {
    const selectors = getSelectors(e.target);
    if (selectors) {
      record({
        type: 'doubleClick',
        selectors,
        offsetX: Math.round(e.offsetX),
        offsetY: Math.round(e.offsetY)
      });
    }
  }, true);

  // Input/change events (debounced to capture final value)
  document.addEventListener('input', (e) => {
    const el = e.target;
    const selectors = getSelectors(el);
    if (!selectors) return;

    const key = `input-${el.id || el.name || selectors[0]?.[0] || Math.random()}`;
    debounce(key, () => {
      record({
        type: 'change',
        selectors,
        value: el.value || ''
      });
    }, 500);
  }, true);

  // Special keys (Enter, Tab, Escape, arrows, etc.)
  document.addEventListener('keydown', (e) => {
    const specialKeys = [
      'Enter', 'Tab', 'Escape', 'Backspace', 'Delete',
      'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight',
      'Home', 'End', 'PageUp', 'PageDown', 'F1', 'F2', 'F3', 'F4', 'F5'
    ];

    if (specialKeys.includes(e.key)) {
      record({ type: 'keyDown', key: e.key });
    } else if (e.metaKey || e.ctrlKey) {
      // Capture keyboard shortcuts (Cmd+C, Ctrl+V, etc.)
      if (e.key.length === 1) {
        const modifiers = [];
        if (e.metaKey) modifiers.push('Meta');
        if (e.ctrlKey) modifiers.push('Control');
        if (e.altKey) modifiers.push('Alt');
        if (e.shiftKey) modifiers.push('Shift');
        record({ 
          type: 'keyDown', 
          key: e.key.toUpperCase(),
          modifiers: modifiers.length > 0 ? modifiers : undefined
        });
      }
    }
  }, true);

  // Scroll events (debounced, only significant scrolls)
  let lastScrollY = window.scrollY;
  let lastScrollX = window.scrollX;
  
  window.addEventListener('scroll', () => {
    debounce('scroll', () => {
      const deltaY = Math.abs(window.scrollY - lastScrollY);
      const deltaX = Math.abs(window.scrollX - lastScrollX);
      
      if (deltaY > 200 || deltaX > 200) {
        record({ 
          type: 'scroll', 
          x: Math.round(window.scrollX), 
          y: Math.round(window.scrollY)
        });
        lastScrollY = window.scrollY;
        lastScrollX = window.scrollX;
      }
    }, 300);
  }, true);

  // Navigation tracking for SPAs
  setInterval(checkNavigation, 500);
  
  // Popstate (back/forward buttons)
  window.addEventListener('popstate', () => {
    setTimeout(checkNavigation, 50);
  });

  // Flush debounced events before page unload
  window.addEventListener('beforeunload', () => {
    debounceTimers.forEach((timer) => clearTimeout(timer));
  });

  console.log('[AgentOS Recorder] Active - Priority: ARIA > data-testid > text > label > ID > CSS');
})();




